import{_ as e}from"./index-5c9403ba.js";import{T as t,U as a,bV as n}from"./vendor-13527336.js";const o={},s={class:"story"},i=n('<div class="title" data-v-ee1637dc>One-Way Data Flow</div><div class="content" data-v-ee1637dc> All props form a one-way-down binding between the child property and the parent one: when the parent property updates,<span class="hightlight" data-v-ee1637dc>it will flow down to the child, but not the other way around.</span> This prevents child components from accidentally mutating the parent&#39;s state, which can make your app&#39;s data flow harder to understand. In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. </div><div class="title" data-v-ee1637dc>Mutating Object / Array Props</div><div class="content" data-v-ee1637dc>When objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array&#39;s nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations. The main drawback of such mutations is that it allows the child component to affect parent state in a way that isn&#39;t obvious to the parent component, potentially making it more difficult to reason about the data flow in the future.<span class="hightlight2" data-v-ee1637dc>As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design.</span> In most cases, the child should emit an event to let the parent perform the mutation.</div>',4),d=[i];function c(r,h){return t(),a("div",s,d)}const u=e(o,[["render",c],["__scopeId","data-v-ee1637dc"]]);export{u as default};
