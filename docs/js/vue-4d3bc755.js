import{_ as p}from"./index-d6a098fe.js";import{ab as m,a as u,aQ as l,T as a,U as r,a5 as f,$ as n,I as h,ar as v,_ as i,V as b,a3 as k,a2 as V}from"./vendor-09eb5a69.js";const x={setup(){const s=m([{id:1,title:"说一个调试bug时遇到的一个离谱问题",path:"",html:`测试提出一个bug，页面A下一页跳到页面B后，返回上一页，某些原本存在的控制逻辑失效了，
        我拿到这个bug反馈后，寻思这不就是初始化可能没控制到，导致原本的代码没走么，找一找页面A初始化逻辑应该就可以了。</br>当我去找页面A代码时，明确找到初始化控制表单
        展示的部分，业务写的很详细，注释什么的都有，代码很长，初始化生效了，没有问题，可是为什么从下一页到上一页会出问题呢？我就继续找原因，会不会是返回的时候字段或者传参有问题，
        我就去查一下两个页面之间传参是不是一致，控制台打印数据，emmm也正常，没有问题，这就头大了，这数据都没问题，到底是出在哪，最笨的办法，从上一页按钮开始，不断打印数据，
        查看接口返回。我了个去，我发现，上一页的逻辑不是返回上一个路由，而是去到新路由，新路由是公共组件，再从公共组件的动态组件到一个新的路由去，新的路由不是页面A</br>
        新路由不是页面A，我当时惊掉大牙，下楼抽了两只烟都没想明白为啥要到新页面去。找到问题了就好处理了，新页面没有表单控制的逻辑，加上之后正常跑，可是，这么写对么？`},{id:2,title:"模拟丝滑的无限翻页效果",path:"/infiniteScroll",html:"利用鼠标滑轮事件修改外层盒子样式，同时内部判断需要展示哪一张图，图片改变position属性模拟丝滑滚动.注：存在bug,二次滚动问题"},{id:3,title:"星空背景效果",path:"/starrySky",html:"使用SASS，通过设置box-shadow来实现小星星效果"},{id:4,title:"自定义指令v-slide-in",path:"/slidein",html:"封装自定义指令"}]);let t=u("");return{list:s,activeName:t}}},N=["innerHTML"];function g(s,t,y,o,A,B){const c=l("RouterLink"),d=l("el-collapse-item"),_=l("el-collapse");return a(),r("div",null,[f(_,{modelValue:o.activeName,"onUpdate:modelValue":t[0]||(t[0]=e=>o.activeName=e),accordion:"",class:"collapse-content"},{default:n(()=>[(a(!0),r(h,null,v(o.list,e=>(a(),i(d,{key:e.id,title:e.title,name:e.id},{default:n(()=>[b("div",{innerHTML:e.html},null,8,N),e.path?(a(),i(c,{key:0,to:e.path},{default:n(()=>[k("体验一下")]),_:2},1032,["to"])):V("",!0)]),_:2},1032,["title","name"]))),128))]),_:1},8,["modelValue"])])}const T=p(x,[["render",g],["__scopeId","data-v-392f7a7d"]]);export{T as default};
